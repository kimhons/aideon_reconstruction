/**
 * ResolutionExecutor.js
 * 
 * Executes recovery strategies to resolve system errors.
 * Implements the "Intelligent Recovery Tentacle" pattern for autonomous error resolution.
 * 
 * This component is responsible for executing recovery strategies generated by the
 * RecoveryStrategyGenerator, monitoring execution progress, handling rollbacks for failed
 * strategies, and providing feedback for continuous improvement.
 * 
 * @module core/error_recovery/ResolutionExecutor
 */

'use strict';

const { v4: uuidv4 } = require('uuid');
const EventEmitter = require('events');
const ExecutionEngine = require('./execution/ExecutionEngine');
const RollbackManager = require('./execution/RollbackManager');
const MonitoringSystem = require('./execution/MonitoringSystem');
const DistributedCoordinator = require('./execution/DistributedCoordinator');
const SecurityValidator = require('./security/SecurityValidator');
const ResourceManager = require('./resources/ResourceManager');
const UserInterface = require('./interaction/UserInterface');
const ExecutionMetrics = require('./metrics/ExecutionMetrics');

/**
 * Executes recovery strategies to resolve system errors.
 * Implements the "Intelligent Recovery Tentacle" pattern.
 */
class ResolutionExecutor {
  /**
   * Creates a new ResolutionExecutor.
   * @param {Object} dependencies - The dependencies required by the executor.
   * @param {EventBus} dependencies.eventBus - Formalized IPC/Message Bus
   * @param {ScalmFramework} dependencies.scalmFramework - SCALM integration
   * @param {KnowledgeFramework} dependencies.knowledgeFramework - Knowledge base access
   * @param {HtnPlanner} dependencies.htnPlanner - HTN Planner integration
   * @param {SecurityMonitor} dependencies.securityMonitor - Security framework
   * @param {MlLayer} dependencies.mlLayer - ML capabilities
   * @param {DistributedProcessingManager} dependencies.distributedManager - Distributed processing
   * @param {Object} config - Configuration options
   */
  constructor(dependencies, config = {}) {
    if (!dependencies || !dependencies.eventBus) {
      throw new Error('EventBus is required for ResolutionExecutor');
    }

    // Core dependencies
    this.eventBus = dependencies.eventBus;
    this.scalmFramework = dependencies.scalmFramework;
    this.knowledgeFramework = dependencies.knowledgeFramework;
    this.htnPlanner = dependencies.htnPlanner;
    this.securityMonitor = dependencies.securityMonitor;
    this.mlLayer = dependencies.mlLayer;
    this.distributedManager = dependencies.distributedManager;
    
    // Component initialization
    this.executionEngine = new ExecutionEngine(dependencies, config.execution);
    this.rollbackManager = new RollbackManager(dependencies, config.rollback);
    this.monitoringSystem = new MonitoringSystem(dependencies, config.monitoring);
    this.distributedCoordinator = new DistributedCoordinator(dependencies, config.distributed);
    this.securityValidator = new SecurityValidator(dependencies.securityMonitor, dependencies.authManager);
    this.resourceManager = new ResourceManager(dependencies, config.resources);
    this.userInterface = new UserInterface(dependencies, config.userInteraction);
    this.metrics = new ExecutionMetrics();
    
    // Configuration
    this.config = this._mergeConfig(this._getDefaultConfig(), config);
    
    // State
    this.isInitialized = false;
    this.activeExecutions = new Map();
    this.executionHistory = new Map();
    
    // Initialize
    this._initialize();
  }

  /**
   * Initializes the ResolutionExecutor.
   * @private
   */
  async _initialize() {
    try {
      await this._registerEventHandlers();
      await this._initializeComponents();
      
      this.isInitialized = true;
      
      this.eventBus.emit('component:initialized', {
        component: 'ResolutionExecutor',
        timestamp: Date.now()
      });
    } catch (error) {
      this.eventBus.emit('component:initialization:failed', {
        component: 'ResolutionExecutor',
        error: error.message,
        timestamp: Date.now()
      });
      
      throw new Error(`Failed to initialize ResolutionExecutor: ${error.message}`);
    }
  }

  /**
   * Registers event handlers for the ResolutionExecutor.
   * @private
   */
  async _registerEventHandlers() {
    // Strategy events
    this.eventBus.on('strategy:generation:completed', this._handleStrategyGenerationCompleted.bind(this));
    this.eventBus.on('strategy:selected', this._handleStrategySelected.bind(this));

    // System state events
    this.eventBus.on('system:state:changed', this._handleSystemStateChanged.bind(this));
    this.eventBus.on('system:resource:available', this._handleResourceAvailable.bind(this));
    this.eventBus.on('system:resource:depleted', this._handleResourceDepleted.bind(this));

    // Security events
    this.eventBus.on('security:policy:changed', this._handleSecurityPolicyChanged.bind(this));
    this.eventBus.on('security:permission:changed', this._handlePermissionChanged.bind(this));

    // User interaction events
    this.eventBus.on('user:approval:granted', this._handleUserApprovalGranted.bind(this));
    this.eventBus.on('user:approval:denied', this._handleUserApprovalDenied.bind(this));
    this.eventBus.on('user:input:provided', this._handleUserInputProvided.bind(this));

    // Distributed events
    this.eventBus.on('distributed:device:available', this._handleDeviceAvailable.bind(this));
    this.eventBus.on('distributed:device:unavailable', this._handleDeviceUnavailable.bind(this));
    this.eventBus.on('distributed:topology:changed', this._handleTopologyChanged.bind(this));

    // Framework events
    this.eventBus.on('scalm:adaptation:suggested', this._handleScalmAdaptationSuggested.bind(this));
    this.eventBus.on('htn:plan:available', this._handleHtnPlanAvailable.bind(this));
    this.eventBus.on('knowledge:strategy:updated', this._handleKnowledgeStrategyUpdated.bind(this));
  }

  /**
   * Initializes the components of the ResolutionExecutor.
   * @private
   */
  async _initializeComponents() {
    await Promise.all([
      this.executionEngine.initialize(),
      this.rollbackManager.initialize(),
      this.monitoringSystem.initialize(),
      this.distributedCoordinator.initialize(),
      this.securityValidator.initialize(),
      this.resourceManager.initialize(),
      this.userInterface.initialize(),
      this.metrics.initialize()
    ]);
  }

  /**
   * Gets the default configuration for the ResolutionExecutor.
   * @private
   * @returns {Object} The default configuration.
   */
  _getDefaultConfig() {
    return {
      // Execution configuration
      execution: {
        defaultTimeout: 30000, // Default execution timeout in milliseconds
        maxRetries: 3, // Maximum number of retries for failed actions
        parallelLimit: 5, // Maximum number of parallel actions
        batchSize: 10, // Maximum batch size for similar actions
        adaptiveTimeouts: true, // Whether to use adaptive timeouts
      },
      
      // Rollback configuration
      rollback: {
        enabled: true, // Whether rollback is enabled
        snapshotEnabled: true, // Whether to create snapshots for rollback
        maxRollbackDepth: 10, // Maximum depth of rollback chain
        rollbackTimeout: 60000, // Rollback timeout in milliseconds
      },
      
      // Monitoring configuration
      monitoring: {
        interval: 1000, // Monitoring interval in milliseconds
        detailedMetrics: true, // Whether to collect detailed metrics
        anomalyDetection: true, // Whether to enable anomaly detection
        thresholds: { // Monitoring thresholds
          cpu: 80, // CPU usage threshold (percentage)
          memory: 80, // Memory usage threshold (percentage)
          latency: 1000, // Latency threshold in milliseconds
        },
      },
      
      // Security configuration
      security: {
        strictValidation: true, // Whether to use strict security validation
        userApprovalTimeout: 300000, // User approval timeout in milliseconds
        auditLevel: 'detailed', // Audit level (minimal, standard, detailed)
      },
      
      // Distributed configuration
      distributed: {
        enabled: true, // Whether distributed execution is enabled
        minDevices: 1, // Minimum number of devices for distribution
        maxDevices: 10, // Maximum number of devices for distribution
        synchronizationInterval: 5000, // State synchronization interval
        deviceFailureThreshold: 3, // Maximum number of device failures
      },
      
      // Resource configuration
      resources: {
        pooling: true, // Whether to use resource pooling
        preallocation: true, // Whether to preallocate resources
        releaseDelay: 1000, // Delay before releasing resources
      },
      
      // User interaction configuration
      userInteraction: {
        enabled: true, // Whether user interaction is enabled
        notificationLevel: 'important', // Notification level (all, important, critical)
        defaultApprovalBehavior: 'ask', // Default approval behavior (ask, auto-approve, auto-deny)
      },
    };
  }

  /**
   * Merges the default configuration with the provided configuration.
   * @private
   * @param {Object} defaultConfig - The default configuration.
   * @param {Object} userConfig - The user-provided configuration.
   * @returns {Object} The merged configuration.
   */
  _mergeConfig(defaultConfig, userConfig) {
    const mergedConfig = { ...defaultConfig };
    
    // Recursively merge nested objects
    for (const [key, value] of Object.entries(userConfig)) {
      if (value && typeof value === 'object' && !Array.isArray(value) && 
          mergedConfig[key] && typeof mergedConfig[key] === 'object') {
        mergedConfig[key] = this._mergeConfig(mergedConfig[key], value);
      } else {
        mergedConfig[key] = value;
      }
    }
    
    return mergedConfig;
  }

  /**
   * Executes a recovery strategy.
   * @param {Object} strategy - The strategy to execute.
   * @param {Object} context - The execution context.
   * @returns {Promise<Object>} A promise that resolves to the execution result.
   */
  async executeStrategy(strategy, context = {}) {
    if (!this.isInitialized) {
      throw new Error('ResolutionExecutor is not initialized');
    }

    if (!strategy || !strategy.id) {
      throw new Error('Valid strategy is required for execution');
    }

    const executionId = uuidv4();
    const startTime = Date.now();
    
    try {
      // Track active execution
      this.activeExecutions.set(executionId, {
        strategyId: strategy.id,
        startTime,
        status: 'in_progress'
      });

      // Emit start event
      this.eventBus.emit('execution:started', {
        executionId,
        strategyId: strategy.id,
        timestamp: startTime
      });

      // Set up execution timeout
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => {
          reject(new Error(`Strategy execution timed out after ${this.config.execution.defaultTimeout}ms`));
        }, this.config.execution.defaultTimeout);
      });

      // Perform strategy execution with timeout
      const executionPromise = this._performStrategyExecution(strategy, context, executionId);
      const result = await Promise.race([executionPromise, timeoutPromise]);
      
      return this._finalizeExecution(result, executionId, strategy, startTime);
    } catch (error) {
      // Handle execution failure
      return this._handleExecutionFailure(error, executionId, strategy, startTime);
    }
  }

  /**
   * Performs the actual strategy execution.
   * @private
   * @param {Object} strategy - The strategy to execute.
   * @param {Object} context - The execution context.
   * @param {string} executionId - The execution identifier.
   * @returns {Promise<Object>} A promise that resolves to the execution result.
   */
  async _performStrategyExecution(strategy, context, executionId) {
    // Validate strategy
    const validationResult = await this.validateStrategy(strategy, context);
    if (!validationResult.valid) {
      throw new Error(`Strategy validation failed: ${validationResult.reason}`);
    }

    // Create execution plan
    const executionPlan = await this.createExecutionPlan(strategy, context);

    // Allocate resources
    const resourceAllocation = await this.resourceManager.allocateResources(strategy, context);
    if (!resourceAllocation.allocated) {
      throw new Error(`Resource allocation failed: ${resourceAllocation.reason}`);
    }

    // Create snapshot for rollback if enabled
    let snapshot = null;
    if (this.config.rollback.enabled && this.config.rollback.snapshotEnabled) {
      snapshot = await this.rollbackManager.createSnapshot(strategy, context);
    }

    // Start monitoring
    const monitoringSession = await this.monitoringSystem.startMonitoring(strategy, executionId);

    try {
      // Check if distributed execution is needed
      let executionResult;
      if (this._shouldUseDistributedExecution(strategy, context)) {
        // Get available devices
        const devices = await this.distributedManager.getAvailableDevices();
        
        // Create distribution plan
        const distributionPlan = await this.distributedCoordinator.distributeExecution(
          strategy, 
          executionPlan, 
          devices
        );
        
        // Execute distributed
        executionResult = await this.distributedCoordinator.coordinateExecution(
          distributionPlan, 
          context
        );
      } else {
        // Execute locally
        executionResult = await this.executionEngine.execute(
          strategy, 
          executionPlan, 
          context
        );
      }

      // Stop monitoring
      await this.monitoringSystem.stopMonitoring(monitoringSession);

      // Check success criteria
      const successCriteriaMet = await this.monitoringSystem.checkSuccessCriteria(
        strategy, 
        executionResult
      );

      if (!successCriteriaMet) {
        throw new Error('Execution completed but success criteria not met');
      }

      // Release resources
      await this.resourceManager.releaseResources(resourceAllocation.releaseToken);

      // Collect feedback
      const feedback = await this.collectFeedback(strategy, executionResult, context);

      return {
        success: true,
        executionId,
        result: executionResult,
        feedback,
        executionTimeMs: Date.now() - monitoringSession.startTime
      };
    } catch (error) {
      // Stop monitoring
      await this.monitoringSystem.stopMonitoring(monitoringSession);

      // Perform rollback if enabled
      if (this.config.rollback.enabled && snapshot) {
        await this.rollbackExecution(strategy, executionId, error, snapshot);
      }

      // Release resources
      await this.resourceManager.releaseResources(resourceAllocation.releaseToken);

      throw error;
    }
  }

  /**
   * Validates a strategy before execution.
   * @param {Object} strategy - The strategy to validate.
   * @param {Object} context - The validation context.
   * @returns {Promise<Object>} A promise that resolves to the validation result.
   */
  async validateStrategy(strategy, context) {
    try {
      // Basic validation
      if (!strategy) {
        return { valid: false, reason: 'Strategy is null or undefined' };
      }

      if (!strategy.id) {
        return { valid: false, reason: 'Strategy ID is missing' };
      }

      if (!strategy.actions || !Array.isArray(strategy.actions) || strategy.actions.length === 0) {
        return { valid: false, reason: 'Strategy has no actions' };
      }

      // Security validation
      const securityValidation = await this.securityValidator.validateExecution(strategy, context);
      if (!securityValidation.allowed) {
        if (securityValidation.escalationPossible && this.config.userInteraction.enabled) {
          // Request user approval for escalation
          const approvalResult = await this.userInterface.requestApproval({
            type: 'permission_escalation',
            strategy: strategy.id,
            permissions: securityValidation.requiredApprovals,
            reason: 'Security constraints require elevated permissions'
          });

          if (!approvalResult.approved) {
            return { 
              valid: false, 
              reason: 'Permission escalation denied by user',
              securityValidation
            };
          }
        } else {
          return { 
            valid: false, 
            reason: `Security validation failed: ${securityValidation.reason}`,
            securityValidation
          };
        }
      }

      // Resource validation
      const resourceRequirements = this.resourceManager.analyzeResourceRequirements(strategy);
      const resourceAvailability = await this.resourceManager.checkResourceAvailability(resourceRequirements);
      
      if (!resourceAvailability.sufficient) {
        return { 
          valid: false, 
          reason: 'Insufficient resources for strategy execution',
          resourceAvailability
        };
      }

      // Action validation
      const invalidActions = [];
      for (const action of strategy.actions) {
        if (!action.type) {
          invalidActions.push({ action, reason: 'Action type is missing' });
        }
        
        if (!action.target) {
          invalidActions.push({ action, reason: 'Action target is missing' });
        }
      }

      if (invalidActions.length > 0) {
        return { 
          valid: false, 
          reason: 'Invalid actions in strategy',
          invalidActions
        };
      }

      // Context validation
      if (strategy.targetError && context.currentError) {
        if (strategy.targetError.type !== context.currentError.type) {
          return { 
            valid: false, 
            reason: 'Strategy target error type does not match current error',
            targetType: strategy.targetError.type,
            currentType: context.currentError.type
          };
        }
      }

      // Validation successful
      return { 
        valid: true,
        securityValidation,
        resourceAvailability
      };
    } catch (error) {
      return { 
        valid: false, 
        reason: `Validation error: ${error.message}`,
        error: error.message
      };
    }
  }

  /**
   * Creates an execution plan for a strategy.
   * @param {Object} strategy - The strategy to plan.
   * @param {Object} context - The planning context.
   * @returns {Promise<Object>} A promise that resolves to the execution plan.
   */
  async createExecutionPlan(strategy, context) {
    try {
      // Determine execution model
      const executionModel = this._determineExecutionModel(strategy, context);
      
      // Get actions from strategy
      const actions = strategy.actions || [];
      
      // Create plan based on execution model
      let plan;
      
      switch (executionModel) {
        case 'sequential':
          plan = this._createSequentialPlan(actions);
          break;
        case 'parallel':
          plan = this._createParallelPlan(actions);
          break;
        case 'phased':
          plan = this._createPhasedPlan(actions);
          break;
        case 'distributed':
          plan = this._createDistributedPlan(actions, context);
          break;
        default:
          plan = this._createSequentialPlan(actions);
      }
      
      // Enhance plan with HTN Planner if available
      if (this.htnPlanner && strategy.complexity === 'high') {
        try {
          const htnPlan = await this.htnPlanner.createPlan({
            goal: 'recover_from_error',
            context: {
              error: strategy.targetError,
              actions: actions,
              systemState: context.systemState
            }
          });
          
          if (htnPlan && htnPlan.valid) {
            plan = this._mergeWithHtnPlan(plan, htnPlan);
          }
        } catch (error) {
          // Log error but continue with original plan
          console.error('HTN planning failed:', error);
        }
      }
      
      // Add execution metadata
      plan.metadata = {
        executionModel,
        createdAt: Date.now(),
        estimatedDuration: this._estimateExecutionDuration(plan),
        resourceRequirements: this.resourceManager.analyzeResourceRequirements(strategy)
      };
      
      return plan;
    } catch (error) {
      throw new Error(`Failed to create execution plan: ${error.message}`);
    }
  }

  /**
   * Determines the execution model for a strategy.
   * @private
   * @param {Object} strategy - The strategy.
   * @param {Object} context - The context.
   * @returns {string} The execution model.
   */
  _determineExecutionModel(strategy, context) {
    // Check if strategy specifies an execution model
    if (strategy.executionModel) {
      return strategy.executionModel;
    }
    
    // Check for distributed execution
    if (this._shouldUseDistributedExecution(strategy, context)) {
      return 'distributed';
    }
    
    // Check for parallel execution
    if (this._canExecuteInParallel(strategy.actions)) {
      return 'parallel';
    }
    
    // Check for phased execution
    if (this._shouldUsePhased(strategy.actions)) {
      return 'phased';
    }
    
    // Default to sequential
    return 'sequential';
  }

  /**
   * Checks if distributed execution should be used.
   * @private
   * @param {Object} strategy - The strategy.
   * @param {Object} context - The context.
   * @returns {boolean} Whether distributed execution should be used.
   */
  _shouldUseDistributedExecution(strategy, context) {
    // Check if distributed execution is enabled
    if (!this.config.distributed.enabled) {
      return false;
    }
    
    // Check if strategy supports distribution
    if (strategy.distributedCapabilities && !strategy.distributedCapabilities.canDistribute) {
      return false;
    }
    
    // Check if distributed manager is available
    if (!this.distributedManager) {
      return false;
    }
    
    // Check if we're in a distributed environment
    if (!this.distributedManager.isDistributedEnvironment()) {
      return false;
    }
    
    // Check if strategy is complex enough to benefit from distribution
    const isComplex = strategy.actions && strategy.actions.length >= 5;
    
    // Check if we have enough devices
    const hasEnoughDevices = this.distributedManager.getDeviceCount() >= this.config.distributed.minDevices;
    
    return isComplex && hasEnoughDevices;
  }

  /**
   * Checks if actions can be executed in parallel.
   * @private
   * @param {Array<Object>} actions - The actions.
   * @returns {boolean} Whether actions can be executed in parallel.
   */
  _canExecuteInParallel(actions) {
    if (!actions || actions.length <= 1) {
      return false;
    }
    
    // Check for dependencies between actions
    const actionTargets = new Set();
    for (const action of actions) {
      if (actionTargets.has(action.target)) {
        return false; // Actions target the same component, can't parallelize
      }
      actionTargets.add(action.target);
      
      // Check for explicit dependencies
      if (action.dependencies && action.dependencies.length > 0) {
        return false;
      }
    }
    
    return true;
  }

  /**
   * Checks if phased execution should be used.
   * @private
   * @param {Array<Object>} actions - The actions.
   * @returns {boolean} Whether phased execution should be used.
   */
  _shouldUsePhased(actions) {
    if (!actions || actions.length <= 2) {
      return false;
    }
    
    // Check for phases in actions
    let hasPhases = false;
    for (const action of actions) {
      if (action.phase !== undefined) {
        hasPhases = true;
        break;
      }
    }
    
    return hasPhases;
  }

  /**
   * Creates a sequential execution plan.
   * @private
   * @param {Array<Object>} actions - The actions.
   * @returns {Object} The execution plan.
   */
  _createSequentialPlan(actions) {
    return {
      type: 'sequential',
      actions: actions.map((action, index) => ({
        ...action,
        executionOrder: index,
        estimatedDuration: this._estimateActionDuration(action)
      }))
    };
  }

  /**
   * Creates a parallel execution plan.
   * @private
   * @param {Array<Object>} actions - The actions.
   * @returns {Object} The execution plan.
   */
  _createParallelPlan(actions) {
    // Group actions by parallelization batch
    const batches = [];
    let currentBatch = [];
    
    for (const action of actions) {
      if (currentBatch.length >= this.config.execution.parallelLimit) {
        batches.push([...currentBatch]);
        currentBatch = [];
      }
      
      currentBatch.push({
        ...action,
        estimatedDuration: this._estimateActionDuration(action)
      });
    }
    
    if (currentBatch.length > 0) {
      batches.push(currentBatch);
    }
    
    return {
      type: 'parallel',
      batches
    };
  }

  /**
   * Creates a phased execution plan.
   * @private
   * @param {Array<Object>} actions - The actions.
   * @returns {Object} The execution plan.
   */
  _createPhasedPlan(actions) {
    // Group actions by phase
    const phases = new Map();
    
    for (const action of actions) {
      const phase = action.phase || 0;
      if (!phases.has(phase)) {
        phases.set(phase, []);
      }
      
      phases.get(phase).push({
        ...action,
        estimatedDuration: this._estimateActionDuration(action)
      });
    }
    
    // Sort phases by key
    const sortedPhases = Array.from(phases.entries())
      .sort(([a], [b]) => a - b)
      .map(([_, actions]) => actions);
    
    return {
      type: 'phased',
      phases: sortedPhases
    };
  }

  /**
   * Creates a distributed execution plan.
   * @private
   * @param {Array<Object>} actions - The actions.
   * @param {Object} context - The context.
   * @returns {Object} The execution plan.
   */
  _createDistributedPlan(actions, context) {
    // Group actions by target component or system
    const targetGroups = new Map();
    
    for (const action of actions) {
      const target = action.target || 'default';
      if (!targetGroups.has(target)) {
        targetGroups.set(target, []);
      }
      
      targetGroups.get(target).push({
        ...action,
        estimatedDuration: this._estimateActionDuration(action)
      });
    }
    
    // Convert to array of groups
    const groups = Array.from(targetGroups.values());
    
    return {
      type: 'distributed',
      groups,
      deviceRequirements: this._getDeviceRequirements(actions, context)
    };
  }

  /**
   * Gets device requirements for distributed execution.
   * @private
   * @param {Array<Object>} actions - The actions.
   * @param {Object} context - The context.
   * @returns {Object} The device requirements.
   */
  _getDeviceRequirements(actions, context) {
    const requirements = {
      minDevices: 1,
      maxDevices: this.config.distributed.maxDevices,
      capabilities: new Set(),
      affinities: new Map()
    };
    
    // Analyze actions for device requirements
    for (const action of actions) {
      // Add required capabilities
      if (action.requiredCapabilities) {
        action.requiredCapabilities.forEach(cap => requirements.capabilities.add(cap));
      }
      
      // Add device affinities
      if (action.deviceAffinity) {
        const affinity = action.deviceAffinity;
        if (!requirements.affinities.has(affinity)) {
          requirements.affinities.set(affinity, []);
        }
        requirements.affinities.get(affinity).push(action);
      }
    }
    
    // Convert sets to arrays for easier handling
    requirements.capabilities = Array.from(requirements.capabilities);
    requirements.affinities = Array.from(requirements.affinities.entries());
    
    return requirements;
  }

  /**
   * Merges an execution plan with an HTN plan.
   * @private
   * @param {Object} executionPlan - The execution plan.
   * @param {Object} htnPlan - The HTN plan.
   * @returns {Object} The merged plan.
   */
  _mergeWithHtnPlan(executionPlan, htnPlan) {
    // Create a new plan that combines both
    const mergedPlan = { ...executionPlan };
    
    // Add HTN-specific metadata
    mergedPlan.htnEnhanced = true;
    mergedPlan.htnTasks = htnPlan.tasks;
    mergedPlan.htnGoals = htnPlan.goals;
    
    // Enhance actions with HTN task information
    if (executionPlan.type === 'sequential') {
      mergedPlan.actions = executionPlan.actions.map(action => {
        const htnTask = htnPlan.tasks.find(task => task.actionId === action.id);
        if (htnTask) {
          return {
            ...action,
            htnTask: {
              id: htnTask.id,
              preconditions: htnTask.preconditions,
              effects: htnTask.effects,
              dependencies: htnTask.dependencies
            }
          };
        }
        return action;
      });
    } else if (executionPlan.type === 'parallel') {
      mergedPlan.batches = executionPlan.batches.map(batch => 
        batch.map(action => {
          const htnTask = htnPlan.tasks.find(task => task.actionId === action.id);
          if (htnTask) {
            return {
              ...action,
              htnTask: {
                id: htnTask.id,
                preconditions: htnTask.preconditions,
                effects: htnTask.effects,
                dependencies: htnTask.dependencies
              }
            };
          }
          return action;
        })
      );
    } else if (executionPlan.type === 'phased') {
      mergedPlan.phases = executionPlan.phases.map(phase => 
        phase.map(action => {
          const htnTask = htnPlan.tasks.find(task => task.actionId === action.id);
          if (htnTask) {
            return {
              ...action,
              htnTask: {
                id: htnTask.id,
                preconditions: htnTask.preconditions,
                effects: htnTask.effects,
                dependencies: htnTask.dependencies
              }
            };
          }
          return action;
        })
      );
    }
    
    return mergedPlan;
  }

  /**
   * Estimates the duration of an action.
   * @private
   * @param {Object} action - The action.
   * @returns {number} The estimated duration in milliseconds.
   */
  _estimateActionDuration(action) {
    // Use historical data if available
    if (this.knowledgeFramework) {
      try {
        const historicalData = this.knowledgeFramework.getHistoricalActionDuration(action.type, action.target);
        if (historicalData && historicalData.averageDuration) {
          return historicalData.averageDuration;
        }
      } catch (error) {
        // Ignore errors and use default estimation
      }
    }
    
    // Use ML prediction if available
    if (this.mlLayer && this.config.mlEnhancement?.enabled) {
      try {
        const prediction = this.mlLayer.predictActionDuration(action);
        if (prediction && prediction.duration) {
          return prediction.duration;
        }
      } catch (error) {
        // Ignore errors and use default estimation
      }
    }
    
    // Default estimations based on action type
    const defaultDurations = {
      retry: 2000,
      fallback: 3000,
      restart: 5000,
      reconfigure: 2000,
      notify: 1000,
      allocate: 2000,
      deallocate: 1000,
      validate: 1000,
      repair: 5000,
      default: 2000
    };
    
    return defaultDurations[action.type] || defaultDurations.default;
  }

  /**
   * Estimates the duration of an execution plan.
   * @private
   * @param {Object} plan - The execution plan.
   * @returns {number} The estimated duration in milliseconds.
   */
  _estimateExecutionDuration(plan) {
    if (plan.type === 'sequential') {
      // Sum of all action durations
      return plan.actions.reduce((total, action) => total + action.estimatedDuration, 0);
    } else if (plan.type === 'parallel') {
      // Sum of max duration per batch
      return plan.batches.reduce((total, batch) => {
        const maxBatchDuration = Math.max(...batch.map(action => action.estimatedDuration));
        return total + maxBatchDuration;
      }, 0);
    } else if (plan.type === 'phased') {
      // Sum of max duration per phase
      return plan.phases.reduce((total, phase) => {
        const maxPhaseDuration = Math.max(...phase.map(action => action.estimatedDuration));
        return total + maxPhaseDuration;
      }, 0);
    } else if (plan.type === 'distributed') {
      // Estimate based on groups and communication overhead
      const maxGroupDuration = Math.max(
        ...plan.groups.map(group => 
          group.reduce((total, action) => total + action.estimatedDuration, 0)
        )
      );
      
      // Add communication overhead (20%)
      return maxGroupDuration * 1.2;
    }
    
    return 5000; // Default estimation
  }

  /**
   * Monitors the execution of a strategy.
   * @param {Object} strategy - The strategy being executed.
   * @param {Object} executionId - The execution identifier.
   * @returns {Promise<Object>} A promise that resolves to the monitoring result.
   */
  async monitorExecution(strategy, executionId) {
    if (!this.activeExecutions.has(executionId)) {
      throw new Error(`No active execution found with ID ${executionId}`);
    }
    
    const execution = this.activeExecutions.get(executionId);
    const monitoringSession = await this.monitoringSystem.getMonitoringSession(executionId);
    
    if (!monitoringSession) {
      throw new Error(`No monitoring session found for execution ${executionId}`);
    }
    
    return {
      executionId,
      strategyId: strategy.id,
      status: execution.status,
      startTime: execution.startTime,
      elapsedTimeMs: Date.now() - execution.startTime,
      progress: monitoringSession.progress,
      metrics: monitoringSession.metrics,
      anomalies: monitoringSession.anomalies,
      currentAction: monitoringSession.currentAction
    };
  }

  /**
   * Rolls back a failed strategy execution.
   * @param {Object} strategy - The strategy to roll back.
   * @param {Object} executionId - The execution identifier.
   * @param {Object} error - The error that caused the rollback.
   * @param {Object} snapshot - The system snapshot before execution.
   * @returns {Promise<Object>} A promise that resolves to the rollback result.
   */
  async rollbackExecution(strategy, executionId, error, snapshot) {
    try {
      // Emit rollback start event
      this.eventBus.emit('rollback:started', {
        executionId,
        strategyId: strategy.id,
        reason: error.message,
        timestamp: Date.now()
      });
      
      // Determine rollback strategy
      const rollbackStrategy = await this.rollbackManager.determineRollbackStrategy(
        strategy, 
        error, 
        { snapshot }
      );
      
      let rollbackResult;
      
      if (rollbackStrategy.type === 'snapshot') {
        // Restore from snapshot
        rollbackResult = await this.rollbackManager.restoreFromSnapshot(snapshot, {
          executionId,
          strategy,
          error
        });
      } else if (rollbackStrategy.type === 'compensating') {
        // Execute compensating actions
        rollbackResult = await this.rollbackManager.executeCompensatingActions(
          rollbackStrategy.actions,
          {
            executionId,
            strategy,
            error
          }
        );
      } else {
        throw new Error(`Unsupported rollback strategy type: ${rollbackStrategy.type}`);
      }
      
      // Emit rollback completion event
      this.eventBus.emit('rollback:completed', {
        executionId,
        strategyId: strategy.id,
        success: true,
        rollbackType: rollbackStrategy.type,
        timestamp: Date.now()
      });
      
      return {
        success: true,
        rollbackType: rollbackStrategy.type,
        result: rollbackResult
      };
    } catch (rollbackError) {
      // Emit rollback failure event
      this.eventBus.emit('rollback:failed', {
        executionId,
        strategyId: strategy.id,
        error: rollbackError.message,
        originalError: error.message,
        timestamp: Date.now()
      });
      
      return {
        success: false,
        error: rollbackError.message,
        originalError: error.message
      };
    }
  }

  /**
   * Collects feedback from a strategy execution.
   * @param {Object} strategy - The executed strategy.
   * @param {Object} result - The execution result.
   * @param {Object} context - The execution context.
   * @returns {Promise<Object>} A promise that resolves to the feedback.
   */
  async collectFeedback(strategy, result, context) {
    try {
      const feedback = {
        strategyId: strategy.id,
        success: result.success,
        executionTimeMs: result.executionTimeMs || (Date.now() - result.startTime),
        timestamp: Date.now(),
        metrics: {},
        learningSignals: [],
        recommendations: []
      };
      
      // Collect metrics
      if (result.metrics) {
        feedback.metrics = { ...result.metrics };
      }
      
      // Add monitoring metrics if available
      if (result.monitoringData) {
        feedback.metrics.monitoring = result.monitoringData;
      }
      
      // Generate learning signals
      feedback.learningSignals = this._generateLearningSignals(strategy, result, context);
      
      // Generate recommendations
      feedback.recommendations = this._generateRecommendations(strategy, result, context);
      
      // Integrate with SCALM if available
      if (this.scalmFramework) {
        try {
          const scalmFeedback = await this.scalmFramework.processExecutionOutcome({
            strategy,
            result,
            context,
            learningSignals: feedback.learningSignals
          });
          
          if (scalmFeedback) {
            feedback.scalmFeedback = scalmFeedback;
          }
        } catch (error) {
          console.error('SCALM feedback processing failed:', error);
        }
      }
      
      // Integrate with Knowledge Framework if available
      if (this.knowledgeFramework) {
        try {
          await this.knowledgeFramework.recordExecutionOutcome({
            strategyId: strategy.id,
            result,
            context,
            feedback
          });
        } catch (error) {
          console.error('Knowledge Framework recording failed:', error);
        }
      }
      
      return feedback;
    } catch (error) {
      console.error('Feedback collection failed:', error);
      
      // Return minimal feedback on error
      return {
        strategyId: strategy.id,
        success: result.success,
        error: error.message,
        timestamp: Date.now()
      };
    }
  }

  /**
   * Generates learning signals from execution results.
   * @private
   * @param {Object} strategy - The strategy.
   * @param {Object} result - The result.
   * @param {Object} context - The context.
   * @returns {Array<Object>} The learning signals.
   */
  _generateLearningSignals(strategy, result, context) {
    const signals = [];
    
    // Basic success/failure signal
    signals.push({
      type: result.success ? 'success' : 'failure',
      confidence: 1.0,
      strategyId: strategy.id,
      timestamp: Date.now()
    });
    
    // Performance signal
    if (result.executionTimeMs) {
      let performanceRating;
      
      if (result.executionTimeMs < 1000) {
        performanceRating = 'excellent';
      } else if (result.executionTimeMs < 3000) {
        performanceRating = 'good';
      } else if (result.executionTimeMs < 10000) {
        performanceRating = 'acceptable';
      } else {
        performanceRating = 'slow';
      }
      
      signals.push({
        type: 'performance',
        rating: performanceRating,
        executionTimeMs: result.executionTimeMs,
        timestamp: Date.now()
      });
    }
    
    // Resource usage signal
    if (result.metrics && result.metrics.resourceUsage) {
      signals.push({
        type: 'resource_usage',
        usage: result.metrics.resourceUsage,
        timestamp: Date.now()
      });
    }
    
    // Action-specific signals
    if (result.actionResults) {
      for (const actionResult of result.actionResults) {
        if (!actionResult.success) {
          signals.push({
            type: 'action_failure',
            actionType: actionResult.type,
            actionTarget: actionResult.target,
            error: actionResult.error,
            timestamp: Date.now()
          });
        }
      }
    }
    
    return signals;
  }

  /**
   * Generates recommendations based on execution results.
   * @private
   * @param {Object} strategy - The strategy.
   * @param {Object} result - The result.
   * @param {Object} context - The context.
   * @returns {Array<Object>} The recommendations.
   */
  _generateRecommendations(strategy, result, context) {
    const recommendations = [];
    
    // Check if ML enhancement is enabled
    if (!this.mlLayer || !this.config.mlEnhancement?.enabled) {
      return recommendations;
    }
    
    try {
      // Use ML to generate recommendations
      const mlRecommendations = this.mlLayer.generateRecommendations({
        strategy,
        result,
        context
      });
      
      if (mlRecommendations && Array.isArray(mlRecommendations)) {
        return mlRecommendations;
      }
    } catch (error) {
      console.error('ML recommendation generation failed:', error);
    }
    
    // Fallback recommendations
    if (!result.success) {
      recommendations.push({
        type: 'strategy_adjustment',
        description: 'Consider using a different strategy type for this error',
        confidence: 0.7
      });
    }
    
    if (result.executionTimeMs > 5000) {
      recommendations.push({
        type: 'performance_optimization',
        description: 'Strategy execution was slow, consider optimizing or using parallel execution',
        confidence: 0.8
      });
    }
    
    return recommendations;
  }

  /**
   * Finalizes an execution and handles completion.
   * @private
   * @param {Object} result - The execution result.
   * @param {string} executionId - The execution ID.
   * @param {Object} strategy - The strategy.
   * @param {number} startTime - The start time.
   * @returns {Object} The finalized result.
   */
  _finalizeExecution(result, executionId, strategy, startTime) {
    // Update active execution
    this.activeExecutions.set(executionId, {
      strategyId: strategy.id,
      startTime,
      endTime: Date.now(),
      status: 'completed',
      success: result.success
    });
    
    // Add to execution history
    this.executionHistory.set(executionId, {
      strategyId: strategy.id,
      startTime,
      endTime: Date.now(),
      success: result.success,
      executionTimeMs: Date.now() - startTime
    });
    
    // Prune history if it exceeds limit
    this._pruneExecutionHistory();
    
    // Record metrics
    this.metrics.recordMetric('executionTime', Date.now() - startTime);
    this.metrics.recordMetric(result.success ? 'successfulExecutions' : 'failedExecutions', 1);
    
    // Emit completion event
    this.eventBus.emit('execution:completed', {
      executionId,
      strategyId: strategy.id,
      success: result.success,
      executionTimeMs: Date.now() - startTime,
      timestamp: Date.now()
    });
    
    return {
      ...result,
      executionId,
      executionTimeMs: Date.now() - startTime
    };
  }

  /**
   * Handles execution failure.
   * @private
   * @param {Error} error - The error.
   * @param {string} executionId - The execution ID.
   * @param {Object} strategy - The strategy.
   * @param {number} startTime - The start time.
   * @returns {Object} The failure result.
   */
  async _handleExecutionFailure(error, executionId, strategy, startTime) {
    // Update active execution
    this.activeExecutions.set(executionId, {
      strategyId: strategy.id,
      startTime,
      endTime: Date.now(),
      status: 'failed',
      error: error.message
    });
    
    // Add to execution history
    this.executionHistory.set(executionId, {
      strategyId: strategy.id,
      startTime,
      endTime: Date.now(),
      success: false,
      error: error.message,
      executionTimeMs: Date.now() - startTime
    });
    
    // Record metrics
    this.metrics.recordMetric('executionTime', Date.now() - startTime);
    this.metrics.recordMetric('failedExecutions', 1);
    this.metrics.recordMetric('executionErrors', 1);
    
    // Emit failure event
    this.eventBus.emit('execution:failed', {
      executionId,
      strategyId: strategy.id,
      error: error.message,
      executionTimeMs: Date.now() - startTime,
      timestamp: Date.now()
    });
    
    // Collect failure feedback
    const feedback = await this.collectFeedback(
      strategy, 
      { 
        success: false, 
        error: error.message,
        startTime
      }, 
      {}
    );
    
    return {
      success: false,
      executionId,
      error: error.message,
      executionTimeMs: Date.now() - startTime,
      feedback
    };
  }

  /**
   * Prunes the execution history to limit its size.
   * @private
   */
  _pruneExecutionHistory() {
    const maxHistorySize = 100;
    
    if (this.executionHistory.size <= maxHistorySize) {
      return;
    }
    
    // Convert to array and sort by timestamp
    const entries = Array.from(this.executionHistory.entries());
    entries.sort((a, b) => a[1].startTime - b[1].startTime);
    
    // Remove oldest entries
    const entriesToRemove = entries.slice(0, entries.length - maxHistorySize);
    for (const [key] of entriesToRemove) {
      this.executionHistory.delete(key);
    }
  }

  /**
   * Event handler for strategy generation completed.
   * @private
   * @param {Object} data - The event data.
   */
  async _handleStrategyGenerationCompleted(data) {
    // Auto-execute strategy if configured
    if (this.config.autoExecuteStrategies && data.topStrategy) {
      try {
        const strategy = await this._getStrategyById(data.topStrategy);
        if (strategy) {
          await this.executeStrategy(strategy);
        }
      } catch (error) {
        console.error('Auto-execution failed:', error);
      }
    }
  }

  /**
   * Event handler for strategy selected.
   * @private
   * @param {Object} data - The event data.
   */
  async _handleStrategySelected(data) {
    // Auto-execute selected strategy if configured
    if (this.config.autoExecuteSelectedStrategies && data.strategyId) {
      try {
        const strategy = await this._getStrategyById(data.strategyId);
        if (strategy) {
          await this.executeStrategy(strategy);
        }
      } catch (error) {
        console.error('Selected strategy execution failed:', error);
      }
    }
  }

  /**
   * Gets a strategy by ID.
   * @private
   * @param {string} strategyId - The strategy ID.
   * @returns {Promise<Object>} A promise that resolves to the strategy.
   */
  async _getStrategyById(strategyId) {
    // Try to get from knowledge framework
    if (this.knowledgeFramework) {
      try {
        const strategy = await this.knowledgeFramework.getStrategyById(strategyId);
        if (strategy) {
          return strategy;
        }
      } catch (error) {
        console.error('Failed to get strategy from knowledge framework:', error);
      }
    }
    
    // Try to get from event bus
    return new Promise((resolve, reject) => {
      const timeout = setTimeout(() => {
        this.eventBus.removeListener('strategy:retrieved', handleStrategyRetrieved);
        reject(new Error('Strategy retrieval timed out'));
      }, 5000);
      
      const handleStrategyRetrieved = (data) => {
        if (data.strategyId === strategyId) {
          clearTimeout(timeout);
          this.eventBus.removeListener('strategy:retrieved', handleStrategyRetrieved);
          resolve(data.strategy);
        }
      };
      
      this.eventBus.on('strategy:retrieved', handleStrategyRetrieved);
      
      // Request strategy
      this.eventBus.emit('strategy:request', {
        strategyId,
        timestamp: Date.now()
      });
    });
  }

  /**
   * Event handler for system state changed.
   * @private
   * @param {Object} data - The event data.
   */
  _handleSystemStateChanged(data) {
    // Update active executions if needed
  }

  /**
   * Event handler for resource available.
   * @private
   * @param {Object} data - The event data.
   */
  _handleResourceAvailable(data) {
    // Update resource manager
  }

  /**
   * Event handler for resource depleted.
   * @private
   * @param {Object} data - The event data.
   */
  _handleResourceDepleted(data) {
    // Update resource manager
  }

  /**
   * Event handler for security policy changed.
   * @private
   * @param {Object} data - The event data.
   */
  _handleSecurityPolicyChanged(data) {
    // Update security validator
  }

  /**
   * Event handler for permission changed.
   * @private
   * @param {Object} data - The event data.
   */
  _handlePermissionChanged(data) {
    // Update security validator
  }

  /**
   * Event handler for user approval granted.
   * @private
   * @param {Object} data - The event data.
   */
  _handleUserApprovalGranted(data) {
    // Resume execution if waiting for approval
  }

  /**
   * Event handler for user approval denied.
   * @private
   * @param {Object} data - The event data.
   */
  _handleUserApprovalDenied(data) {
    // Cancel execution if waiting for approval
  }

  /**
   * Event handler for user input provided.
   * @private
   * @param {Object} data - The event data.
   */
  _handleUserInputProvided(data) {
    // Resume execution if waiting for input
  }

  /**
   * Event handler for device available.
   * @private
   * @param {Object} data - The event data.
   */
  _handleDeviceAvailable(data) {
    // Update distributed coordinator
  }

  /**
   * Event handler for device unavailable.
   * @private
   * @param {Object} data - The event data.
   */
  _handleDeviceUnavailable(data) {
    // Update distributed coordinator
  }

  /**
   * Event handler for topology changed.
   * @private
   * @param {Object} data - The event data.
   */
  _handleTopologyChanged(data) {
    // Update distributed coordinator
  }

  /**
   * Event handler for SCALM adaptation suggested.
   * @private
   * @param {Object} data - The event data.
   */
  _handleScalmAdaptationSuggested(data) {
    // Apply adaptation if applicable
  }

  /**
   * Event handler for HTN plan available.
   * @private
   * @param {Object} data - The event data.
   */
  _handleHtnPlanAvailable(data) {
    // Update execution plans if applicable
  }

  /**
   * Event handler for knowledge strategy updated.
   * @private
   * @param {Object} data - The event data.
   */
  _handleKnowledgeStrategyUpdated(data) {
    // Update strategy cache if applicable
  }

  /**
   * Shuts down the ResolutionExecutor.
   * @returns {Promise<void>} A promise that resolves when shutdown is complete.
   */
  async shutdown() {
    try {
      // Clean up resources
      this.activeExecutions.clear();
      this.executionHistory.clear();
      
      // Shut down components
      await Promise.all([
        this.executionEngine.shutdown(),
        this.rollbackManager.shutdown(),
        this.monitoringSystem.shutdown(),
        this.distributedCoordinator.shutdown(),
        this.resourceManager.shutdown(),
        this.userInterface.shutdown(),
        this.metrics.shutdown()
      ]);
      
      // Remove event listeners
      this.eventBus.removeAllListeners();
      
      this.isInitialized = false;
      
      this.eventBus.emit('component:shutdown', {
        component: 'ResolutionExecutor',
        timestamp: Date.now()
      });
    } catch (error) {
      this.eventBus.emit('component:shutdown:failed', {
        component: 'ResolutionExecutor',
        error: error.message,
        timestamp: Date.now()
      });
      
      throw new Error(`Failed to shut down ResolutionExecutor: ${error.message}`);
    }
  }
}

module.exports = ResolutionExecutor;
